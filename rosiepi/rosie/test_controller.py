# The MIT License (MIT)
#
# Copyright (c) 2019 Michael Schroeder
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import argparse
import atexit
import datetime
from io import StringIO
import logging
import os
import pathlib
import tempfile
import sys

import pytest

from . import cirpy_actions

from .pytest_rosie import RosieTestController

rosiepi_logger = logging.getLogger(__name__) # pylint: disable=invalid-name

cli_parser = argparse.ArgumentParser(description="rosiepi Test Controller")
cli_parser.add_argument(
    "board",
    help="Name of the board to run test(s) on."
)
cli_parser.add_argument(
    "build_ref",
    default=None,
    help="Tag or commit to build CircuitPython from."
)

class TestResultStream(StringIO):
    """ Container for handling test result output, sending to
        both the stdout (print) and retaining the stream for
        logging and database usage.
    """
    def write(self, data, quiet=True):
        """ Override StringIO's write command so that we can also
            print to stdout.
        """
        if isinstance(data, bytes):
            data = str(data, encoding="utf-8")

        if not quiet:
            print(data)

        if data[-1:] != "\n":
            data = data + "\n"
        super().write(data)

# pylint: disable=too-many-instance-attributes
class TestController():
    """ Main class to handle testing operations.

    :param: board: The name of the board to run tests on. Must match
                   an available board in `circuitpython/tools/cpboard.py`.
    :param: build_ref: A reference to the tag/commit to test. This will
                       usually be generated by the GitHub Checks API.

    :returns: a `TestController` instance.
    """

    def __init__(self, board, build_ref):
        atexit.register(self.__cleanup)

        self.state = "init"

        self.run_date = datetime.datetime.utcnow().strftime(
            "%d-%b-%Y,%H:%M:%S%Z"
        )

        self.build_ref = build_ref
        self.board_name = board

        tmp_prefix = str(f".rosiepi_{build_ref[:5]}_")
        self.clone_tmp_dir = tempfile.TemporaryDirectory(prefix=tmp_prefix)
        self.clone_dir_path = pathlib.Path(self.clone_tmp_dir.name)
        sys.path.append(str(self.clone_dir_path.resolve()))
        rosiepi_logger.info("tmp dir: %s", self.clone_dir_path)

        self.tests_collected = 0
        self.tests_passed = 0
        self.tests_failed = 0
        self._result = pytest.ExitCode.NO_TESTS_COLLECTED

        init_msg = [
            "Initiating rosiepi...",
            f" - Date/Time: {self.run_date}",
            f" - Test commit: {build_ref}",
            f" - Target board: {board}",
            " - Fetching commit..."
        ]
        self.log = TestResultStream()
        self.log.write("\n".join(init_msg))

        try:
            cirpy_actions.clone_commit(
                str(self.clone_dir_path.resolve()),
                build_ref
            )
        except RuntimeError as clone_err:
            err_msg = [
                #f"  - Failed fetch commit: {self.build_ref}",
                f"   - {clone_err.args[0]}",
                "-"*60,
                "Closing RosiePi"
            ]
            self.log.write("\n".join(err_msg))
            self.state = "error"
            return

        try:
            from tests import pyboard # pylint: disable=import-outside-toplevel
            self.log.write(
                " - Connecting to target board..."
            )
            kwargs = {
                'wait': 20,
            }
            self.board = pyboard.CPboard.from_try_all(board, **kwargs)
            board_connect_msg = [
                f"   - Serial Number: {self.board.serial_number}",
                f"   - Disk Drive: {self.board.disk.path}",
            ]
            self.log.write("\n".join(board_connect_msg))
            self.state = "board_connected"
            self.log.write("-"*60)

        except (RuntimeError, ImportError) as conn_err:
            err_msg = [
                f"Failed to connect to: {self.board_name}",
                conn_err.args[0],
                "-"*60,
                "Closing RosiePi"
            ]
            self.log.write("\n".join(err_msg))
            self.state = "error"

    def __cleanup(self):
        """ Cleanup function to ensure temp directory is destroyed.
        """
        try:
            with self.board as board:
                board.reset()
        except Exception as err: # pylint: disable=broad-except
            rosiepi_logger.info("Board reset failed: %s", err)

    @property
    def result(self):
        """ The ``pytest.ExitCode`` result of the test instance.
        """
        return self._result

    def start_test(self):
        """ Starts the first step of a test event.
            1. Attempts to build the firmware.
            2. Uploads the built firmware onto the target board.
        """
        self.state = "starting_fw_prep"
        self.log.write(
            f"Preparing Firmware..."
        )

        try:
            fw_build_dir = cirpy_actions.build_fw(
                self.board_name,
                self.log,
                self.clone_dir_path.resolve()
            )

            self.log.write(f"Updating Firmware on: {self.board_name}")
            cirpy_actions.update_fw(
                self.board,
                self.board_name,
                os.path.join(fw_build_dir, "firmware.uf2"),
                self.log
            )

        except RuntimeError as fw_err:
            err_msg = [
                f"Failed update firmware on: {self.board_name}",
                fw_err.args[0],
                "-"*60,
                "Closing RosiePi"
            ]
            self.log.write("\n".join(err_msg), quiet=True)
            self.state = "error"

        self.log.write("-"*60)

        if self.state != "error":
            self.state = "running_tests"
            self.run_tests()

    def run_tests(self):
        """ Runs the second step of a test event, by calling ``pytest`` to
            run the tests located in the circuitpython repository. Since
            the location pointed to is the version we're testing, any
            new test scripts or changes will be used.
        """

        rosie_tests_dir = str(
            self.clone_dir_path.resolve()
            / "tests"
            / "circuitpython"
            / "rosie_tests"
        )

        pytest.main([rosie_tests_dir], plugins=[RosieTestController(self)])

def main():
    """ The entrypoint to run a test instance, without involving the
        physaCI system (see ``run_rosiepi.py``). Primarily only used for
        development purposes.
    """
    cli_args = cli_parser.parse_args()

    test_control = TestController(cli_args.board, cli_args.build_ref)
    if test_control.state != "error":
        test_control.start_test()

    #print()
    print("test log:")
    print(test_control.log.getvalue())
    print("exitstatus:", test_control.result, int(test_control.result))
